[
["r.html", "Capítulo 3 R! 3.1 Variáveis Básicas 3.2 Vetores 3.3 Classe 3.4 Converter objetos 3.5 Array 3.6 Matrizes e a função matrix 3.7 Listas 3.8 Data.frames 3.9 Tempo e Data 3.10 Fatores", " Capítulo 3 R! A linguagem R pode ser usada desde uma simples calculadora até uma poderosa ferramenta estatística, seja para análise de dados, seja para machine learning, ou seja, com R você pode alcançar tudo o que sempre sonhou. Focaremos em Linux, mas R e RStudio estão disponíveis para Windows e Mac também. Documentação: Intro. I/O. Quer fazer um pacote? Veja, aqui e aqui. Stackoverflow te ajudará em horas de desespero. Nesse capítulo veremos o básico da linguagem, como a idéia é cobrir o máximo de conteúdo possível, passaremos bem rápido pelos objetos e pelas variáveis, com alguns exercícios para melhor entendimento. 3.1 Variáveis Básicas Podemos armazenar valores, strings ou operadores lógicos nas chamadas variáveis básicas, é com elas que podemos fazer operações básicas e transformar o RStudio em uma calculadora superpoderosa. Existem 5 tipos de variáveis básicas, sendo elas: Numeric 1: valores numéricos com ou sem casa decimal 5+2.3 ## [1] 7.3 pi ## [1] 3.141593 Character a: com eles podemos armazenar strings, como o título de um gráfico titulo &lt;- &quot;Isso é uma string&quot; titulo ## [1] &quot;Isso é uma string&quot; Integer 1: são valores inteiros Complex 0+1i: também é possível armazenar valores complexos nas variáveis básicas 3 + 4i ## [1] 3+4i Logical TRUE: são os famosos operadores Booleanos, que permitem realizar comparações entre variáveis ou dados (Você não pode criar uma variável com os nome TRUE ou FALSE, esses nomes são reservados pelo R) 1 == 2 ## [1] FALSE 3.2 Vetores Vetores permitem que você armazene dados em uma sequência 1D de qualquer um dos tipos listados nas variáveis básicas mais o formato “cru” (raw) que o modo de rmazenamento de bytes, por exemplo: c(“A”, “C”, “D”) 1:5 = c(1, 2, 3, 4, 5) c(TRUE, FALSE) c(1i, -1i) Importante: ao contrário do C ou do Python, na linguagem R, a contagem das posições dos vetores começa do 1 e NÃO do zero! 3.3 Classe Como foi possível notar, todas as variáveis pertencem a alguma classe, dessa forma, a função class permite descobrir qual o tipo de variável que se está utilizando: x &lt;- c(1,2,3) class(x) ## [1] &quot;numeric&quot; Exercício Qual a classe dos seguintes vetores? c(1, “C”, “D”) c(1, NA, “D”) c(1, NA, NaN) 3.4 Converter objetos Às vezes quando trabalhamos com dados, podemos precisar “arredondar” valores ou converter vetores em listas, para isso existem algumas funções especiais. 3.4.1 as Um modo de forçar um objeto a assumir outra classe é por meio da função as: as.integer(c(1.5, 2.9, 1)) ## [1] 1 2 1 Note que a função apenas converte os números de decimais para inteiros, sem arredondar para o número mais próximo. Pergunta: o que acontece quando se tenta converter o seguinte vetor? as.numeric(c(1, “C”, “D”)) 3.4.2 merge e melt Nem sempre os conjuntos de dados que você encontrar pela vida estarão no formato desejado para plotar e/ou analisar estatísticamente, dessa forma, essas duas funções poderão ajudar na sua jornada: Merge: permite a união entre dois Data.frames ([3.10])(#Data.frames), seja por colunas em comum ou linhas em comum Melt: do pacote reshape2, permite que você armazene colunas iguais em uma única, de acordo com o nome especificado 3.5 Array Ao contrário do unidimensional vetor, arrays permitm que você armazene dados em diversas dimensões, sendo sempre com o mesmo comprimento. # Vamos dar uma olhada nos argumentos da função args(array) ## function (data = NA, dim = length(data), dimnames = NULL) ## NULL Não esqueça do TAB Dessa forma, é preciso “informar” ao R qual o número de dimensões que você quer no seu array: (a &lt;- array(data = 0, dim = c(1,1))) ## [,1] ## [1,] 0 class(a) ## [1] &quot;matrix&quot; No caso acima como só foram desiginadas duas dimensões, o array é igual a uma matriz. (a &lt;- array(data = 0, dim = c(3,3,1))) ## , , 1 ## ## [,1] [,2] [,3] ## [1,] 0 0 0 ## [2,] 0 0 0 ## [3,] 0 0 0 class(a) ## [1] &quot;array&quot; Como dá pra ver acima, é possível armazenar diversos elementos num array, como por exemplo as dimensões que utilizamos no dia-a-dia de modelos numéricos: espaço (x,y,z) e tempo (z). Dessa forma, podemos criar arrays a partir de vetores e armazená-los em diverssas dimensões. vetor1 &lt;- c(1,2,3,4,5) vetor2 &lt;- c(10,12,14,16,18,20,22,24) (a &lt;- array(data = c(vetor1,vetor2), dim = c(3,3,2))) ## , , 1 ## ## [,1] [,2] [,3] ## [1,] 1 4 12 ## [2,] 2 5 14 ## [3,] 3 10 16 ## ## , , 2 ## ## [,1] [,2] [,3] ## [1,] 18 24 3 ## [2,] 20 1 4 ## [3,] 22 2 5 class(a) ## [1] &quot;array&quot; Se você quiser, também é possível nomear as colunas e linhas do seu array: colunas &lt;- c(&quot;col1&quot;, &quot;col2&quot;, &quot;col3&quot;) linhas &lt;- c(&quot;lin1&quot;, &quot;lin2&quot;, &quot;lin3&quot;) array(data = c(vetor1,vetor2),dim = c(3,3,2),dimnames = list(linhas,colunas)) ## , , 1 ## ## col1 col2 col3 ## lin1 1 4 12 ## lin2 2 5 14 ## lin3 3 10 16 ## ## , , 2 ## ## col1 col2 col3 ## lin1 18 24 3 ## lin2 20 1 4 ## lin3 22 2 5 Além disso, sempre que precisar acessar elementos do seu array é só especificar aas dimensões como para mostrar o elemento de um vetor. a[1,2,2] #(linha, coluna, matriz) ## [1] 24 Exercício: Crie um array com 3 dimensões, contendo três linhas e 4 quatro colunas, acesse o elemento da segunda linha e terceira coluna desse array. Não esqueça de verificar a classe desse objeto! 3.6 Matrizes e a função matrix Uma matriz é um array com duas dimensões, sendo necessário informar o número de colunas e linhas, mas não o de dimensões. [linhas, colunas] Assim como nos array, só são permitidos elementos da mesma clase! Argumentos da função matrix args(matrix) ## function (data = NA, nrow = 1, ncol = 1, byrow = FALSE, dimnames = NULL) ## NULL Colocando dados numa matriz: (m1 &lt;- matrix(data = 1:(4*4), nrow = 4, ncol = 4)) ## [,1] [,2] [,3] [,4] ## [1,] 1 5 9 13 ## [2,] 2 6 10 14 ## [3,] 3 7 11 15 ## [4,] 4 8 12 16 dim(m1) ## [1] 4 4 Por padrão, a opção “byrow” é igual a FALSE, quando passamos para TRUE, é possível organizar os dados por linha. (m2 &lt;- matrix(data = 1:(4*4), nrow = 4, ncol = 4, byrow = TRUE)) ## [,1] [,2] [,3] [,4] ## [1,] 1 2 3 4 ## [2,] 5 6 7 8 ## [3,] 9 10 11 12 ## [4,] 13 14 15 16 Exercício: Construa uma matriz com três linhas que contenha os números de 1 a 9. 3.7 Listas Já as listas permitem que você armazene qualquer tipo de variável básica, independente da classe, dessa forma, podemos colocar numa lista: número, caracteres, argumentos lógicos, ou que você quiser: list(list(list(list(1)))) ## [[1]] ## [[1]][[1]] ## [[1]][[1]][[1]] ## [[1]][[1]][[1]][[1]] ## [1] 1 Isso faz com que elas sejam bastante versáteis e sirvam para armazenar o que você precisar, mas elas só podem ter uma dimensão, como uma fia. Já os objetos armazenados dentro da lista não precisam ter a mesma dimensão. (x &lt;- list(1, &quot;a&quot;, TRUE, 1 + 4i)) ## [[1]] ## [1] 1 ## ## [[2]] ## [1] &quot;a&quot; ## ## [[3]] ## [1] TRUE ## ## [[4]] ## [1] 1+4i Exercício:Crie uma lista contendo um vetor, uma matriz e um data frame e acesse o segundo elemento dela. #Para facilitar, já vamos te dar o data frame: my_df &lt;- mtcars[1:10,] 3.8 Data.frames Os data frames são uma forma de armazenar seus dados em um formato parecido com uma planilha de excel. Você pode pensar num data frame como uma matriz que armazena em cala coluna um dado diferente, ou como uma lista onde todos os elementos tem o mesmo comprimento. (df &lt;- data.frame(a = 1:3)) ## a ## 1 1 ## 2 2 ## 3 3 names(df) ## [1] &quot;a&quot; class(df) ## [1] &quot;data.frame&quot; mode(df) ## [1] &quot;list&quot; É normalmente num data frame que você importará os seus dados e vale saber como visualizar algumas informações básicas sobre ele direto no seu console, para isso, vamos pegar como exemplo o conjunto mtcars da base de dados do R: df &lt;- mtcars head(df) #mostra as sete primeiras linhas do data frame ## mpg cyl disp hp drat wt qsec vs am gear carb ## Mazda RX4 21.0 6 160 110 3.90 2.620 16.46 0 1 4 4 ## Mazda RX4 Wag 21.0 6 160 110 3.90 2.875 17.02 0 1 4 4 ## Datsun 710 22.8 4 108 93 3.85 2.320 18.61 1 1 4 1 ## Hornet 4 Drive 21.4 6 258 110 3.08 3.215 19.44 1 0 3 1 ## Hornet Sportabout 18.7 8 360 175 3.15 3.440 17.02 0 0 3 2 ## Valiant 18.1 6 225 105 2.76 3.460 20.22 1 0 3 1 Para ver as últimas linahs do data frame basta usar a função tail(), já uma função muito útil é a summary() que apresenta um “resumo” dos seus dados, como média, mediana, mínimos e máximos para cada coluna do data frame. summary(df) ## mpg cyl disp hp ## Min. :10.40 Min. :4.000 Min. : 71.1 Min. : 52.0 ## 1st Qu.:15.43 1st Qu.:4.000 1st Qu.:120.8 1st Qu.: 96.5 ## Median :19.20 Median :6.000 Median :196.3 Median :123.0 ## Mean :20.09 Mean :6.188 Mean :230.7 Mean :146.7 ## 3rd Qu.:22.80 3rd Qu.:8.000 3rd Qu.:326.0 3rd Qu.:180.0 ## Max. :33.90 Max. :8.000 Max. :472.0 Max. :335.0 ## drat wt qsec vs ## Min. :2.760 Min. :1.513 Min. :14.50 Min. :0.0000 ## 1st Qu.:3.080 1st Qu.:2.581 1st Qu.:16.89 1st Qu.:0.0000 ## Median :3.695 Median :3.325 Median :17.71 Median :0.0000 ## Mean :3.597 Mean :3.217 Mean :17.85 Mean :0.4375 ## 3rd Qu.:3.920 3rd Qu.:3.610 3rd Qu.:18.90 3rd Qu.:1.0000 ## Max. :4.930 Max. :5.424 Max. :22.90 Max. :1.0000 ## am gear carb ## Min. :0.0000 Min. :3.000 Min. :1.000 ## 1st Qu.:0.0000 1st Qu.:3.000 1st Qu.:2.000 ## Median :0.0000 Median :4.000 Median :2.000 ## Mean :0.4062 Mean :3.688 Mean :2.812 ## 3rd Qu.:1.0000 3rd Qu.:4.000 3rd Qu.:4.000 ## Max. :1.0000 Max. :5.000 Max. :8.000 Iremos trabalhar bastante com data frames daqui pra frente, eles se tornarão aliados muito poderosos. 3.9 Tempo e Data O R trabalha com três classe de tempo: POSIXct, POSIXlt e Date, sendo que POSIXct se refere ao número de segundos desde o início de 1970 no modo UTC, enquanto que POSIXct armazena as datas como uma lista, contendo segundos, minutos, horas, dias, meses, etc. (a &lt;- ISOdate(year = 2018, month = 4, day = 5)) ## [1] &quot;2018-04-05 12:00:00 GMT&quot; class(a) ## [1] &quot;POSIXct&quot; &quot;POSIXt&quot; (b &lt;- ISOdate(year = 2018, month = 4, day = 5, tz = &quot;Americas/Sao_Paulo&quot;)) ## [1] &quot;2018-04-05 12:00:00 Americas&quot; Já a classe Date, armazena as datas como o número de dias contados a partir de 1970. (c &lt;- as.Date(Sys.time())) ## [1] &quot;2018-06-02&quot; class(c) ## [1] &quot;Date&quot; Caso você precise, o pacote nanotime permite trabalhar com nano segundos. Também é possível fazer sequências: hoje &lt;- Sys.time() (a &lt;- seq.POSIXt(from = hoje, by = 3600, length.out = 24)) ## [1] &quot;2018-06-01 22:49:44 -03&quot; &quot;2018-06-01 23:49:44 -03&quot; ## [3] &quot;2018-06-02 00:49:44 -03&quot; &quot;2018-06-02 01:49:44 -03&quot; ## [5] &quot;2018-06-02 02:49:44 -03&quot; &quot;2018-06-02 03:49:44 -03&quot; ## [7] &quot;2018-06-02 04:49:44 -03&quot; &quot;2018-06-02 05:49:44 -03&quot; ## [9] &quot;2018-06-02 06:49:44 -03&quot; &quot;2018-06-02 07:49:44 -03&quot; ## [11] &quot;2018-06-02 08:49:44 -03&quot; &quot;2018-06-02 09:49:44 -03&quot; ## [13] &quot;2018-06-02 10:49:44 -03&quot; &quot;2018-06-02 11:49:44 -03&quot; ## [15] &quot;2018-06-02 12:49:44 -03&quot; &quot;2018-06-02 13:49:44 -03&quot; ## [17] &quot;2018-06-02 14:49:44 -03&quot; &quot;2018-06-02 15:49:44 -03&quot; ## [19] &quot;2018-06-02 16:49:44 -03&quot; &quot;2018-06-02 17:49:44 -03&quot; ## [21] &quot;2018-06-02 18:49:44 -03&quot; &quot;2018-06-02 19:49:44 -03&quot; ## [23] &quot;2018-06-02 20:49:44 -03&quot; &quot;2018-06-02 21:49:44 -03&quot; Funções úteis: weekdays, month, julian weekdays(a) ## [1] &quot;sexta&quot; &quot;sexta&quot; &quot;sábado&quot; &quot;sábado&quot; &quot;sábado&quot; &quot;sábado&quot; &quot;sábado&quot; ## [8] &quot;sábado&quot; &quot;sábado&quot; &quot;sábado&quot; &quot;sábado&quot; &quot;sábado&quot; &quot;sábado&quot; &quot;sábado&quot; ## [15] &quot;sábado&quot; &quot;sábado&quot; &quot;sábado&quot; &quot;sábado&quot; &quot;sábado&quot; &quot;sábado&quot; &quot;sábado&quot; ## [22] &quot;sábado&quot; &quot;sábado&quot; &quot;sábado&quot; months(a) ## [1] &quot;junho&quot; &quot;junho&quot; &quot;junho&quot; &quot;junho&quot; &quot;junho&quot; &quot;junho&quot; &quot;junho&quot; &quot;junho&quot; ## [9] &quot;junho&quot; &quot;junho&quot; &quot;junho&quot; &quot;junho&quot; &quot;junho&quot; &quot;junho&quot; &quot;junho&quot; &quot;junho&quot; ## [17] &quot;junho&quot; &quot;junho&quot; &quot;junho&quot; &quot;junho&quot; &quot;junho&quot; &quot;junho&quot; &quot;junho&quot; &quot;junho&quot; julian(a) #dia Juliano* ## Time differences in days ## [1] 17684.08 17684.12 17684.16 17684.20 17684.24 17684.28 17684.33 ## [8] 17684.37 17684.41 17684.45 17684.49 17684.53 17684.58 17684.62 ## [15] 17684.66 17684.70 17684.74 17684.78 17684.83 17684.87 17684.91 ## [22] 17684.95 17684.99 17685.03 ## attr(,&quot;origin&quot;) ## [1] &quot;1970-01-01 GMT&quot; *Para mais informações: https://en.wikipedia.org/wiki/Julian_day: 3.10 Fatores Os factors podem ser um pouco infernais. Dê uma olhada em R INFERNO. Usados em análise estatísica, fatores são usados para armazenar variáveis categóricas, ou seja, é uma variável que pode pertencer a um número limitado de categorias, como por exemplo, dias da semana. Já uma variável contínua pode assumir um um número infinito de valores. a &lt;- seq.POSIXt(from = hoje , by = 3600, length.out = 24*7) aa &lt;- weekdays(a) class(aa) ## [1] &quot;character&quot; factor(aa) ## [1] sexta sexta sábado sábado sábado sábado sábado sábado ## [9] sábado sábado sábado sábado sábado sábado sábado sábado ## [17] sábado sábado sábado sábado sábado sábado sábado sábado ## [25] sábado sábado domingo domingo domingo domingo domingo domingo ## [33] domingo domingo domingo domingo domingo domingo domingo domingo ## [41] domingo domingo domingo domingo domingo domingo domingo domingo ## [49] domingo domingo segunda segunda segunda segunda segunda segunda ## [57] segunda segunda segunda segunda segunda segunda segunda segunda ## [65] segunda segunda segunda segunda segunda segunda segunda segunda ## [73] segunda segunda terça terça terça terça terça terça ## [81] terça terça terça terça terça terça terça terça ## [89] terça terça terça terça terça terça terça terça ## [97] terça terça quarta quarta quarta quarta quarta quarta ## [105] quarta quarta quarta quarta quarta quarta quarta quarta ## [113] quarta quarta quarta quarta quarta quarta quarta quarta ## [121] quarta quarta quinta quinta quinta quinta quinta quinta ## [129] quinta quinta quinta quinta quinta quinta quinta quinta ## [137] quinta quinta quinta quinta quinta quinta quinta quinta ## [145] quinta quinta sexta sexta sexta sexta sexta sexta ## [153] sexta sexta sexta sexta sexta sexta sexta sexta ## [161] sexta sexta sexta sexta sexta sexta sexta sexta ## Levels: domingo quarta quinta sábado segunda sexta terça São muito úteis para regressões, plotes e resumos estatísitcos, uma vez que limita o número de possibilidades para a qual o dado pertença. Além disso, é possível estabelecer “níveis” que vão designar a categoria do seu dado. ab &lt;- factor(x = aa, levels = c(&quot;Monday&quot;, &quot;Tuesday&quot;, &quot;Wednesday&quot;, &quot;Thursday&quot;, &quot;Friday&quot;, &quot;Saturday&quot;, &quot;Sunday&quot;)) levels(ab) ## [1] &quot;Monday&quot; &quot;Tuesday&quot; &quot;Wednesday&quot; &quot;Thursday&quot; &quot;Friday&quot; &quot;Saturday&quot; ## [7] &quot;Sunday&quot; Exercício: Converta o vetor abaixo em um fator e mostre os seus níveis genero &lt;- c(“Masculino”, “Masculino”, “Feminino”, “Masculino”, “Feminino”, “Feminino”) Se tudo pareceu muito corrido, não se preocupe, todos esses conceitos serão praticados mais adiante! "]
]
